#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('sidekonnect:server');
var http = require('http');
let models = require('../models');
const jwt = require('jsonwebtoken');
const base64url = require('base64url');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Adding socketio middleware and Setting up socketio namespace "connection" for new sockets
 */

var io = require('socket.io')(server, {
  handlePreflightRequest: (req, res) => {
    const headers = {
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
        "Access-Control-Allow-Origin": req.headers.origin, //or the specific origin you want to give access to,
        "Access-Control-Allow-Credentials": true
    };
    res.writeHead(200, headers);
    res.end();
  }
});

io.on('connection', (socket) => {
  console.log('A user as connected !');
  const currentUserToken = socket.handshake.query['token'];
  const secretKey = process.env.SECRET_KEY;

  // HELPER FUNCTIONS TO GENERATOR ROOM # AND NAME
  const RoomGenerator = (inputID) => {
    let callerInfo = jwt.verify(currentUserToken, secretKey);
    let callerID = parseInt(callerInfo.id);
    let receiverID = parseInt(inputID);
    let roomID = callerID > receiverID ? (receiverID + '-' + callerID) : (callerID + '-' + receiverID);

    return roomID;
  };
  
  const NameGenerator = () => {
    let callerInfo = jwt.verify(currentUserToken, secretKey);
    let callerName = callerInfo.firstname + ' ' + callerInfo.lastname;

    return callerName;
  };

  const EmailGenerator = () => {
    let callerInfo = jwt.verify(currentUserToken, secretKey);
    let callerEmail = callerInfo.email;

    return callerEmail;
  };

  socket.on('join_room', (receiverID) => {
    console.log('TRYING TO JOIN A ROOM!!!!!!!!!!!!', receiverID);

    try {
      let callerName = NameGenerator();
      let roomID = RoomGenerator(receiverID);
      socket.join(roomID);

      let joinData = {
        'action': 'joining',
        'msg': 'success',
        'join': (`${callerName} has joined the room ${roomID}`)
      };

      io.sockets.in(roomID).emit('join_room', joinData);
    } catch (err) {
      let joinData = {
        'action': 'joining',
        'msg': 'success',
        'join': 'Unable to join rooms...'
      };
      io.emit('join_room', joinData);
    };
  });

  socket.on('join_call', (data) => {
    console.log('TRYING TO MAKE A CALL !!!!!!');

    try {
      let currentUserInfo = jwt.verify(currentUserToken, secretKey);
      let currentUserId = currentUserInfo.id;
      let callerName = NameGenerator();
      let callerEmail = EmailGenerator();
      let roomID = RoomGenerator(data.receiverID);
      let secretRoomEncoded = base64url(currentUserToken);
      let tokboxRoom = "https://tokbox.com/embed/embed/ot-embed.js?embedId=853df113-5f97-4ed9-9d0d-06ccae7a92a2&room=" + secretRoomEncoded + "&iframe=true";

      let callingData = {
        'action': 'calling',
        'msg': 'success',
        'callerEmail': callerEmail,
        'caller': callerName,
        'callerID': currentUserId,
        'receiverID': data.receiverID,
        'tokbox': tokboxRoom,
      };

      io.sockets.in(roomID).emit('join_room', callingData);
    } catch (err) {
      let callingData = {
        'action': 'calling',
        'msg': 'Unable to make that call...'
      };
      io.emit('join_room', callingData);
    };
  });

  socket.on('accept_call', (data) => {
    console.log('accepting call...');

    try {
      let roomID = RoomGenerator(data.receiverID);

      let callingData = {
        'action': 'accepting',
        'msg': 'success',
        'callerEmail': callerEmail,
        'caller': callerName,
        'receiverID': data.receiverID,
        'tokbox': tokboxRoom,
      };

      io.sockets.in(roomID).emit('join_room', callingData);
    } catch (err) {
      let callingData = {
        'action': 'accepting',
        'msg': 'Unable to make that call...'
      };
      io.emit('join_room', callingData);
    };
  })

  socket.on('disconnect_call', (data) => {
    console.log('disconnecting call...');

    try {
      let roomID = RoomGenerator(data.receiverID);

      let callingData = {
        'action': 'disconnecting',
        'msg': 'success',
        'callerEmail': callerEmail,
        'caller': callerName,
        'receiverID': data.receiverID,
        'tokbox': tokboxRoom,
      };

      io.sockets.in(roomID).emit('join_room', callingData);
    } catch (err) {
      let callingData = {
        'action': 'disconnecting',
        'msg': 'Unable to disconnect that call...'
      };
      io.emit('join_room', callingData);
    };
  });

  socket.on('removeuser', (userID) => {
    console.log('TRYING TO remove USER.... ' + userID);
    try {
      let currentUserInfo = jwt.verify(currentUserToken, secretKey);
      // FIND FRIEND'S INFO
      models.buddy.findOne({
        where : {
          friend_id: userID,
          userId: currentUserInfo.id
        }
      }).then(user => {
        if (user) {
          // IF CURRENT USER FOUND, FIND THE REQUESTED FRIEND TO BE ADDED
          console.log(user);
        };
      })
    } catch (err) {
      console.log('error removing user..');
    };
  });

  socket.on('disconnect', () => {
    console.log('A user disconnected..........');
  });
});

/**
 * Listen on provided port, on all network interfaces.
 */

return models.sequelize.sync().then(result => {
  server.listen(port);
  server.on('error', onError);
  server.on('listening', onListening);
  console.log('Listening on port: ' + port);
});

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
